/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package learned_league_to_anki

import org.jsoup.Jsoup
import org.jsoup.nodes.Document
import java.io.File

class App {
    val greeting: String
        get() {
            return "Hello world."
        }
}

class Card(val question: String, val answer: String, val season: String, val questionNumber: String, val matchDay: String? = null) {
    override fun toString(): String {
        return "${question}\t${answer.toLowerCase()}\t${season}\t${matchDay?:""}\t${questionNumber}"
    }
}


fun main(args: Array<String>) {
    // Built in
//    println(App().greeting)

    var url = if (args.size > 0) args[0] else null
    var outputFile = if (args.size > 1) args[1] else null

    // Disable these once the app works!
    url = "https://learnedleague.com/seasons.php?77"
    outputFile = "/tmp/output"

    val doc = Jsoup.connect(url).get()

    val cards = makeCards(doc)
    val output = cards.map { it.toString() }.joinToString("\n")
    File(outputFile).writeText(output)
}

fun isMiniLeague(doc: Document): Boolean {
    return doc.location().contains("/mini/")
}

fun isSingleMiniLeagueMatch(doc: Document): Boolean {
   return isMiniLeague(doc) && doc.location().contains(Regex("&[0-9]+$"))
}

// We should probably pass a URL instead of a doc here - we branch based on URL only.
private fun makeCards(doc: Document): MutableList<Card> {
    if (doc.location().contains("oneday.php")) {
        return oneDay(doc)
    } else if (isSingleMiniLeagueMatch(doc)) {
        return miniLeagueMatch(doc)
    } else if (isMiniLeague(doc)) {
        return fullMiniLeague(doc)
    } else if (doc.location().contains("/match.php")) {
        return singleMatchDay(doc)
    } else if (doc.location().contains("/seasons.php")) {
        return fullSeason(doc)
    } else {
        throw Exception("Can't parse that type of match!")
    }
}

private fun fullSeason(doc: Document): MutableList<Card> {
    val result = mutableListOf<Card>()

    for (i in 1..25) {
        val url = doc.location().replace("seasons", "match") + "&${i}"
        Thread.sleep(2000)

        val nextDoc = Jsoup.connect(url).get()
        val nextCards = singleMatchDay(nextDoc)
        result.addAll(nextCards)
    }

    return result
}

private fun singleMatchDay(doc: Document): MutableList<Card> {
    // Warning: ML copypasta; not clear if it'll work.
    val cards = mutableListOf<Card>()
    for (i in 1..6) {
        val title = doc.select("h1").text()
                // Normal format in the document is "${date}: ${title} Match Day ${matchDay} Results"
                // The format I want is "${title} 1D"
                .replaceBeforeLast(':', "")
                .replaceAfter("Match Day", "")
                .replace("Match Day", "")
                .substring(1)

        // Match day = the number after the last '&' in URL
        val matchDay = doc.location().replace(Regex(".*&"), "")

        // The div that has the questions and answers in it.
        // Note that answer div IDs contain a spurious `1` after the question-number
        val questionWrapper = doc.select("div:has(div > div > div > #Q${i}1)")
        // ind-Q20 is the class on each question
        val question = questionWrapper.select("div.ind-Q20")[i - 1]
        val answer = questionWrapper.select("#Q${i}1ANS")

        val card = Card(question.text(), answer.text(), title, i.toString(), matchDay)
        cards.add(card)
    }
    return cards
}

// Proof of concept: print the question and answer for all 12 1D questions.
// Note that this behavior is all 1D-specific.
private fun oneDay(doc: Document): MutableList<Card> {
    val cards = mutableListOf<Card>()
    for (i in 1..12) {
        val title = doc.select("h1").text()
                // Normal format in the document is "${date}: LL One-Day Special: ${title}"
                // The format I want is "${title} 1D"
                .replaceBeforeLast(':', "")
                .substring(1) + " 1D"

        // The div that has the questions and answers in it.
        val questionWrapper = doc.select("div:has(div > div > #Q${i})")
        val question = questionWrapper.select("p")[i - 1]
        val answer = questionWrapper.select("#Q${i}ANS")

        val card = Card(question.text(), answer.text(), title, i.toString())
        cards.add(card)
    }
    return cards
}

private fun miniLeagueMatch(doc: Document): MutableList<Card> {
    val cards = mutableListOf<Card>()
    for (i in 1..6) {
        val title = doc.select("h1").text()
                // Normal format in the document is "${date}: ${title} Match Day ${matchDay} Results"
                // The format I want is "${title} 1D"
                .replaceBeforeLast(':', "")
                .replaceAfter("Match Day", "")
                .replace("Match Day", "")
                .substring(1) + " ML"

        // Match day = the number after the last '&' in URL
        val matchDay = doc.location().replace(Regex(".*&"), "")

        // The div that has the questions and answers in it.
        // One more level of nesting than in 1Ds.
        val questionWrapper = doc.select("div:has(div > div > div > #Q${i})")
        // ind-Q20 is the class on each question
        val question = questionWrapper.select("div.ind-Q20")[i - 1]
        val answer = questionWrapper.select("#Q${i}ANS")

        val card = Card(question.text(), answer.text(), title, i.toString(), matchDay)
        cards.add(card)
    }
    return cards
}

fun fullMiniLeague(doc: Document): MutableList<Card> {
    val result = mutableListOf<Card>()

    // Note ML championships (MD 12) aren't visible without authenticating
    for (i in 1..11) {
        val url = doc.location() + "&${i}"
        Thread.sleep(2000)

        val nextDoc = Jsoup.connect(url).get()
        val nextCards = miniLeagueMatch(nextDoc)
        result.addAll(nextCards)
    }

    return result
}
